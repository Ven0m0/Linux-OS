#!/usr/bin/env bash
# apt-fuzz â€” compact skim/fzf TUI for apt / apt-fast
set -euo pipefail; shopt -s nullglob globstar
export LC_ALL=C LANG=C

: "${SHELL:=${BASH:-/bin/bash}}"
: "${XDG_CACHE_HOME:=${HOME:-$HOME}/.cache}"
CACHE_DIR="${XDG_CACHE_HOME%/}/apt-fuzz"
mkdir -p -- "$CACHE_DIR" &>/dev/null || :
: "${APT_FUZZ_CACHE_TTL:=86400}"
: "${APT_FUZZ_CACHE_MAX_BYTES:=0}"
: "${APT_FUZZ_ANSI:=1}"

# -------------------------
# Tool detection
# -------------------------
if command -v sk &>/dev/null; then
  FINDER=sk
elif command -v fzf &>/dev/null; then
  FINDER=fzf
else
  echo "Please install skim (sk) or fzf." >&2; exit 1
fi

if command -v fd &>/dev/null; then
  FIND_TOOL=fd
elif command -v fdfind &>/dev/null; then
  FIND_TOOL=fdfind
else
  FIND_TOOL=find
fi

FINDER_OPTS=(--layout=reverse-list --tiebreak=index --no-sort --no-hscroll)
[[ "$APT_FUZZ_ANSI" == 1 ]] && FINDER_OPTS+=(--ansi)
[[ -n ${APT_FUZZ_FINDER_OPTS:-} ]] && read -r -a FINDER_OPTS <<< "$APT_FUZZ_FINDER_OPTS"

# -------------------------
# Manager detection
# -------------------------
HAS_APT_FAST=0
command -v apt-fast &>/dev/null && HAS_APT_FAST=1 || :
PRIMARY_MANAGER=apt-get
(( HAS_APT_FAST )) && PRIMARY_MANAGER=apt-fast
command -v apt-get &>/dev/null || PRIMARY_MANAGER=apt

# -------------------------
# Small utils
# -------------------------
byte_to_human(){
  local bytes="${1:-0}" i=0 pow=1
  local -a units=(B K M G T)
  while [[ $bytes -ge $(( pow*1024 )) && $i -lt 4 ]]; do
    pow=$(( pow*1024 )); ((i++))
  done
  local value10=$(( (bytes*10 + (pow/2))/pow ))
  local whole=$(( value10/10 )) dec=$(( value10%10 ))
  if (( dec>0 )); then printf '%d.%d%s' "$whole" "$dec" "${units[i]}"
  else printf '%d%s' "$whole" "${units[i]}"; fi
}
_cache_file_for(){ printf '%s/%s.cache' "$CACHE_DIR" "${1//[^a-zA-Z0-9._+-]/_}"; }
_cache_mins(){ printf '%d' $(( (APT_FUZZ_CACHE_TTL + 59)/60 )); }

# -------------------------
# Optimized cache index + eviction
# -------------------------
CACHE_INDEX="${CACHE_DIR}/.index"

_update_cache_index(){
  local tmp="${CACHE_DIR}/.index.$$"
  if [[ $FIND_TOOL != "find" ]]; then
    "$FIND_TOOL" -d 1 -t f "$CACHE_DIR" -0 2>/dev/null \
      | xargs -0 -r stat -c '%n|%s|%Y' >"$tmp" 2>/dev/null || :
  else
    find "$CACHE_DIR" -maxdepth 1 -type f -print0 2>/dev/null \
      | xargs -0 -r stat -c '%n|%s|%Y' >"$tmp" 2>/dev/null || :
  fi
  mv -f "$tmp" "$CACHE_INDEX"
}

_cache_info_from_index(){
  awk -F'|' '
    BEGIN{total=0; files=0; oldest=0}
    {files++; total+=$2; if(oldest==0||$3<oldest) oldest=$3}
    END{print total,files,oldest}
  ' "$CACHE_INDEX" 2>/dev/null || echo "0 0 0"
}

evict_old_cache(){
  local mmin cutoff total files oldest limit
  mmin=$(_cache_mins)
  cutoff=$(( $(date +%s) - mmin*60 ))
  limit=$APT_FUZZ_CACHE_MAX_BYTES

  [[ -f $CACHE_INDEX ]] || _update_cache_index

  awk -F'|' -v cutoff="$cutoff" -v limit="$limit" '
    {
      if($3<cutoff){ system("rm -f -- \""$1"\""); next }
      files[++i]=$1; sizes[i]=$2; mtimes[i]=$3; total+=$2
    }
    END{
      if(limit>0 && total>limit){
        n=i
        while(total>limit && n>0){
          oldest=1
          for(j=2;j<=i;j++) if(mtimes[j]<mtimes[oldest]) oldest=j
          system("rm -f -- \""files[oldest]"\"")
          total-=sizes[oldest]
          mtimes[oldest]=9999999999
          n--
        }
      }
    }
  ' "$CACHE_INDEX"

  _update_cache_index
}
_update_cache_index   # ensure index exists at script start

# -------------------------
# Cached preview helpers
# -------------------------
_generate_preview(){
  local pkg="$1" out tmp
  out="$(_cache_file_for "$pkg")"
  tmp="$(mktemp "${out}.XXXXXX.tmp")" || tmp="${out}.$$.$RANDOM.tmp"
  {
    apt-cache show "$pkg" 2>/dev/null || :
    printf '\n--- changelog (first 200 lines) ---\n'
    apt-get changelog "$pkg" 2>/dev/null | sed -n '1,200p' || :
  } > "$tmp" 2>/dev/null
  sed -i 's/\x1b\[[0-9;]*m//g' "$tmp" &>/dev/null || :
  mv -f "$tmp" "$out"; chmod 644 "$out" &>/dev/null || :
}

_cached_preview_print(){
  local pkg="$1" f now f_mtime
  evict_old_cache
  f="$(_cache_file_for "$pkg")"
  now=$(date +%s)
  f_mtime=$(stat -c %Y -- "$f" 2>/dev/null || echo 0)
  if [[ -f $f && (( now - f_mtime < APT_FUZZ_CACHE_TTL )) ]]; then
    cat "$f"
  else
    _generate_preview "$pkg"
    cat "$f" 2>/dev/null || :
  fi
}
export -f _cached_preview_print _generate_preview

# -------------------------
# Manager runner
# -------------------------
run_mgr(){
  local action="$1"; shift || :
  local pkgs=("$@") cmd=()
  case "$PRIMARY_MANAGER" in
    apt-fast)
      case "$action" in
        update) cmd=(apt-fast update);;
        upgrade) cmd=(apt-fast upgrade -y);;
        autoremove) cmd=(apt-fast autoremove -y);;
        clean) cmd=(apt-fast clean);;
        *) cmd=(apt-fast "$action" -y "${pkgs[@]}");;
      esac ;;
    apt-get)
      case "$action" in
        update) cmd=(apt-get update);;
        upgrade) cmd=(apt-get upgrade -y);;
        install) cmd=(apt-get install -y "${pkgs[@]}");;
        remove) cmd=(apt-get remove -y "${pkgs[@]}");;
        purge) cmd=(apt-get purge -y "${pkgs[@]}");;
        autoremove) cmd=(apt-get autoremove -y);;
        clean) cmd=(apt-get clean);;
        *) cmd=(apt-get "$action" "${pkgs[@]}");;
      esac ;;
    *)
      case "$action" in
        update) cmd=(apt update);;
        upgrade) cmd=(apt upgrade -y);;
        install) cmd=(apt install -y "${pkgs[@]}");;
        remove) cmd=(apt remove -y "${pkgs[@]}");;
        purge) cmd=(apt purge -y "${pkgs[@]}");;
        autoremove) cmd=(apt autoremove -y);;
        clean) cmd=(apt clean);;
        *) cmd=(apt "$action" "${pkgs[@]}");;
      esac ;;
  esac
  printf 'Running: sudo %s\n' "${cmd[*]}"
  sudo "${cmd[@]}"
}

# -------------------------
# Package listing
# -------------------------
list_all_packages(){ [[ -f "$CACHE_DIR/pkgnames.cache" ]] && cat "$CACHE_DIR/pkgnames.cache" || apt-cache pkgnames; }
list_installed(){ [[ -f "$CACHE_DIR/installed.cache" ]] && cat "$CACHE_DIR/installed.cache" || dpkg-query -W -f='${Package}\n'; }
list_upgradable(){ [[ -f "$CACHE_DIR/upgradable.cache" ]] && cat "$CACHE_DIR/upgradable.cache" || apt list --upgradable 2>/dev/null | awk -F/ 'NR>1{print $1}'; }

# -------------------------
# Backup / Restore
# -------------------------
backup_installed(){
  local out="${1:-pkglist-$(date +%F).txt}"
  dpkg-query -W -f='${binary:Package}\n' | sort -u >"$out"
  printf 'Saved: %s\n' "$out"
}

restore_from_file(){
  local file="$1"
  [[ -f $file ]] || { echo "File not found: $file" >&2; return 1; }
  mapfile -t pkgs < <(sed '/^$/d' "$file")
  [[ ${#pkgs[@]} -eq 0 ]] && { echo "No packages."; return 0; }
  mapfile -t sel < <(printf '%s\n' "${pkgs[@]}" | "$FINDER" "${FINDER_OPTS[@]}" --multi --height=40% --prompt="Confirm install> ")
  [[ ${#sel[@]} -eq 0 ]] && return
  run_mgr install "${sel[@]}"
}

# -------------------------
# Status header
# -------------------------
_status_header(){
  local stats files size age
  stats=$(_cache_info_from_index)
  IFS=' ' read -r total files oldest <<< "$stats"
  if [[ $oldest -eq 0 ]]; then age="0m"; else age=$(( ( $(date +%s) - oldest )/60 ))m; fi
  size=$(byte_to_human "$total")
  printf 'manager: %s | cache: %s files, %s, oldest: %s' "$PRIMARY_MANAGER" "$files" "$size" "$age"
}

# -------------------------
# Menus
# -------------------------
menu_search_packages(){
  local sel pkgs
  sel=$(list_all_packages | "$FINDER" "${FINDER_OPTS[@]}" --multi --height=60% --prompt="Search> " \
    --preview="_cached_preview_print {}" --preview-window=right:60% --header="$(_status_header)" \
    --bind 'tab:toggle+down,ctrl-a:select-all,ctrl-d:deselect-all')
  [[ -n $sel ]] || return
  mapfile -t pkgs < <(printf '%s\n' "$sel")
  run_mgr install "${pkgs[@]}"
}

menu_installed_packages(){
  local sel pkgs
  sel=$(list_installed | "$FINDER" "${FINDER_OPTS[@]}" --multi --height=60% --prompt="Installed> " \
    --preview="_cached_preview_print {}" --preview-window=right:60% --header="$(_status_header)" \
    --bind 'tab:toggle+down,ctrl-a:select-all,ctrl-d:deselect-all')
  [[ -n $sel ]] || return
  mapfile -t pkgs < <(printf '%s\n' "$sel")
  action_menu_for_pkgs "${pkgs[@]}"
}

menu_upgradable(){
  local sel pkgs
  sel=$(list_upgradable | "$FINDER" "${FINDER_OPTS[@]}" --multi --height=40% --prompt="Upgradable> " \
    --preview="_cached_preview_print {}" --preview-window=right:60% --header="$(_status_header)" \
    --bind 'tab:toggle+down,ctrl-a:select-all,ctrl-d:deselect-all')
  [[ -n $sel ]] || return
  mapfile -t pkgs < <(printf '%s\n' "$sel")
  run_mgr upgrade "${pkgs[@]}"
}

action_menu_for_pkgs(){
  local pkgs=("$@") choice
  choice=$(printf 'Remove\nPurge\nSkip' | "$FINDER" --height=10% --prompt="Action> ")
  case "$choice" in
    Remove) run_mgr remove "${pkgs[@]}";;
    Purge) run_mgr purge "${pkgs[@]}";;
    Skip) return;;
  esac
}

menu_backup_restore(){
  local choice f
  choice=$(printf 'Backup\nRestore\nCancel' | "$FINDER" --height=10% --prompt="Backup/Restore> ")
  case "$choice" in
    Backup) backup_installed;;
    Restore)
      f=$(printf '%s\n' ./*pkglist*.txt 2>/dev/null | "$FINDER" --height=20% --prompt="Select file> ")
      [[ -n $f ]] && restore_from_file "$f"
      ;;
    Cancel) return;;
  esac
}

menu_maintenance(){
  local choice
  choice=$(printf 'Update\nUpgrade\nAutoremove\nClean\nCancel' | "$FINDER" --height=15% --prompt="Maintenance> ")
  case "$choice" in
    Update) run_mgr update;;
    Upgrade) run_mgr upgrade;;
    Autoremove) run_mgr autoremove;;
    Clean) run_mgr clean;;
    Cancel) return;;
  esac
}

# -------------------------
# Background prefetch
# -------------------------
_prefetch_package_lists(){
  apt-cache pkgnames > "$CACHE_DIR/pkgnames.cache" 2>/dev/null &
  dpkg-query -W -f='${Package}\n' > "$CACHE_DIR/installed.cache" 2>/dev/null &
  apt list --upgradable 2>/dev/null | awk -F/ 'NR>1{print $1}' > "$CACHE_DIR/upgradable.cache" &
}

_prefetch_package_previews(){
  local pkg
  [[ -f "$CACHE_DIR/installed.cache" ]] || return
  while IFS= read -r pkg; do
    _generate_preview "$pkg" &
  done < "$CACHE_DIR/installed.cache"
  wait 2>/dev/null || :
  _update_cache_index
}

_prefetch_package_lists &

# -------------------------
# Self install/uninstall
# -------------------------
_install_self(){
  local dest="${HOME%/}/.local/bin/apt-fuzz" compdir="${HOME%/}/.local/share/bash-completion/completions"
  mkdir -p -- "${HOME%/}/.local/bin"
  cp -f -- "$0" "$dest"
  chmod +x -- "$dest"
  printf 'Installed: %s\n' "$dest"
  mkdir -p -- "$compdir"
  cat >"$compdir/apt-fuzz" <<'BASHCOMP'
_complete_apt_fuzz(){
  local cur="${COMP_WORDS[COMP_CWORD]}" opts="search installed upgradable install remove purge backup restore maintenance choose-manager quit"
  COMPREPLY=()
  if [[ ${COMP_CWORD} -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "$opts" -- "$cur") ); return 0
  fi
  case "${COMP_WORDS[1]}" in
    install|remove|purge) COMPREPLY=( $(compgen -W "$(apt-cache pkgnames | tr '\n' ' ')" -- "$cur") );;
    restore) COMPREPLY=( $(compgen -f -- "$cur") );;
  esac
}
complete -F _complete_apt_fuzz apt-fuzz
BASHCOMP
  printf 'Completion installed: %s/apt-fuzz\n' "$compdir"
}

_uninstall_self(){
  local dest="${HOME%/}/.local/bin/apt-fuzz" compfile="${HOME%/}/.local/share/bash-completion/completions/apt-fuzz"
  [[ -f $dest ]] && rm -f -- "$dest" && echo "Removed $dest"
  [[ -f $compfile ]] && rm -f -- "$compfile" && echo "Removed $compfile"
}

# -------------------------
# Main TUI loop
# -------------------------
main_menu(){
  local choice
  while true; do
    choice=$(printf 'Search\nInstalled\nUpgradable\nBackup/Restore\nMaintenance\nQuit' \
      | "$FINDER" --height=30% --prompt="apt-fuzz> " --header="$(_status_header)")
    case "$choice" in
      Search) menu_search_packages;;
      Installed) menu_installed_packages;;
      Upgradable) menu_upgradable;;
      "Backup/Restore") menu_backup_restore;;
      Maintenance) menu_maintenance;;
      Quit|"" ) break;;
    esac
  done
}

# -------------------------
# Entry point
# -------------------------
case "${1:-}" in
  --install) _install_self "${2:-}"; exit 0;;
  --uninstall) _uninstall_self "${2:-}"; exit 0;;
esac

main_menu
